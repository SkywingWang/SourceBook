<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc -->
<title>MemorySegment (Java SE 15 &amp; JDK 15)</title>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="description" content="declaration: module: jdk.incubator.foreign, package: jdk.incubator.foreign, interface: MemorySegment">
<meta name="generator" content="javadoc/ClassWriterImpl">
<meta name="keywords" content="jdk.incubator.foreign.MemorySegment interface">
<meta name="keywords" content="READ">
<meta name="keywords" content="WRITE">
<meta name="keywords" content="CLOSE">
<meta name="keywords" content="ACQUIRE">
<meta name="keywords" content="HANDOFF">
<meta name="keywords" content="ALL_ACCESS">
<meta name="keywords" content="baseAddress()">
<meta name="keywords" content="spliterator()">
<meta name="keywords" content="ownerThread()">
<meta name="keywords" content="withOwnerThread()">
<meta name="keywords" content="byteSize()">
<meta name="keywords" content="withAccessModes()">
<meta name="keywords" content="hasAccessModes()">
<meta name="keywords" content="accessModes()">
<meta name="keywords" content="asSlice()">
<meta name="keywords" content="isAlive()">
<meta name="keywords" content="close()">
<meta name="keywords" content="fill()">
<meta name="keywords" content="copyFrom()">
<meta name="keywords" content="mismatch()">
<meta name="keywords" content="asByteBuffer()">
<meta name="keywords" content="toByteArray()">
<meta name="keywords" content="ofByteBuffer()">
<meta name="keywords" content="ofArray()">
<meta name="keywords" content="allocateNative()">
<meta name="keywords" content="mapFromPath()">
<meta name="keywords" content="ofNativeRestricted()">
<link rel="stylesheet" type="text/css" href="../../../../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../script-dir/jquery-ui.min.css" title="Style">
<link rel="stylesheet" type="text/css" href="../../../../jquery-ui.overrides.css" title="Style">
<script type="text/javascript" src="../../../../script.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-3.5.1.min.js"></script>
<script type="text/javascript" src="../../../../script-dir/jquery-ui.min.js"></script>
</head>
<body class="class-declaration-page">
<script type="text/javascript">var data = {"i0":6,"i1":1,"i2":1,"i3":1,"i4":6,"i5":6,"i6":6,"i7":6,"i8":6,"i9":6,"i10":6,"i11":6,"i12":6,"i13":1,"i14":6,"i15":1,"i16":1,"i17":1,"i18":1,"i19":1,"i20":1,"i21":1,"i22":1,"i23":1,"i24":6,"i25":1,"i26":6,"i27":6,"i28":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"]};
var altColor = "alt-color";
var rowColor = "row-color";
var tableTab = "table-tab";
var activeTableTab = "active-table-tab";
var pathtoroot = "../../../../";
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<div class="flex-box">
<header role="banner" class="flex-header">
<nav role="navigation">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="top-nav" id="navbar.top">
<div class="skip-nav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.top.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MemorySegment.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="about-language"><div style="margin-top: 14px;"><strong>Java SE 15 &amp; JDK 15</strong> </div></div>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<div class="nav-list-search"><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</div>
</div>
<!-- ========= END OF TOP NAVBAR ========= -->
<span class="skip-nav" id="skip.navbar.top">
<!--   -->
</span></nav>
</header>
<div class="flex-content">
<main role="main">
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="sub-title"><span class="module-label-in-type">Module</span>&nbsp;<a href="../../../module-summary.html">jdk.incubator.foreign</a></div>
<div class="sub-title"><span class="package-label-in-type">Package</span>&nbsp;<a href="package-summary.html">jdk.incubator.foreign</a></div>
<h1 title="Interface MemorySegment" class="title">Interface MemorySegment</h1>
</div>
<section class="description">
<dl class="notes">
<dt>All Superinterfaces:</dt>
<dd><code><a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></code></dd>
</dl>
<dl class="notes">
<dt>All Known Subinterfaces:</dt>
<dd><code><a href="MappedMemorySegment.html" title="interface in jdk.incubator.foreign">MappedMemorySegment</a></code></dd>
</dl>
<hr>
<pre>public interface <span class="type-name-label">MemorySegment</span>
extends <a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></pre>
<div class="block">A memory segment models a contiguous region of memory. A memory segment is associated with both spatial
 and temporal bounds. Spatial bounds ensure that memory access operations on a memory segment cannot affect a memory location
 which falls <em>outside</em> the boundaries of the memory segment being accessed. Temporal bounds ensure that memory access
 operations on a segment cannot occur after a memory segment has been closed (see <a href="#close()"><code>close()</code></a>).
 <p>
 All implementations of this interface must be <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>;
 use of identity-sensitive operations (including reference equality (<code>==</code>), identity hash code, or synchronization) on
 instances of <code>MemorySegment</code> may have unpredictable results and should be avoided. The <code>equals</code> method should
 be used for comparisons.
 <p>
 Non-platform classes should not implement <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a> directly.

 <h2>Constructing memory segments from different sources</h2>

 There are multiple ways to obtain a memory segment. First, memory segments backed by off-heap memory can
 be allocated using one of the many factory methods provided (see <a href="#allocateNative(jdk.incubator.foreign.MemoryLayout)"><code>allocateNative(MemoryLayout)</code></a>,
 <a href="#allocateNative(long)"><code>allocateNative(long)</code></a> and <a href="#allocateNative(long,long)"><code>allocateNative(long, long)</code></a>). Memory segments obtained
 in this way are called <em>native memory segments</em>.
 <p>
 It is also possible to obtain a memory segment backed by an existing heap-allocated Java array,
 using one of the provided factory methods (e.g. <a href="#ofArray(int%5B%5D)"><code>ofArray(int[])</code></a>). Memory segments obtained
 in this way are called <em>array memory segments</em>.
 <p>
 It is possible to obtain a memory segment backed by an existing Java byte buffer (see <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>),
 using the factory method <a href="#ofByteBuffer(java.nio.ByteBuffer)"><code>ofByteBuffer(ByteBuffer)</code></a>.
 Memory segments obtained in this way are called <em>buffer memory segments</em>. Note that buffer memory segments might
 be backed by native memory (as in the case of native memory segments) or heap memory (as in the case of array memory segments),
 depending on the characteristics of the byte buffer instance the segment is associated with. For instance, a buffer memory
 segment obtained from a byte buffer created with the <a href="../../../../java.base/java/nio/ByteBuffer.html#allocateDirect(int)"><code>ByteBuffer.allocateDirect(int)</code></a> method will be backed
 by native memory.
 <p>
 Finally, it is also possible to obtain a memory segment backed by a memory-mapped file using the factory method
 <a href="#mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)"><code>mapFromPath(Path, long, long, FileChannel.MapMode)</code></a>. Such memory segments are called <em>mapped memory segments</em>
 (see <a href="MappedMemorySegment.html" title="interface in jdk.incubator.foreign"><code>MappedMemorySegment</code></a>).
 <p>
 Array and buffer segments are effectively <em>views</em> over existing memory regions which might outlive the
 lifecycle of the segments derived from them, and can even be manipulated directly (e.g. via array access, or direct use
 of the <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> API) by other clients. As a result, while sharing array or buffer segments is possible,
 it is strongly advised that clients wishing to do so take extra precautions to make sure that the underlying memory sources
 associated with such segments remain inaccessible, and that said memory sources are never aliased by more than one segment
 at a time - e.g. so as to prevent concurrent modifications of the contents of an array, or buffer segment.

 <h2>Closing a memory segment</h2>

 Memory segments are closed explicitly (see <a href="#close()"><code>close()</code></a>). When a segment is closed, it is no longer
 <em>alive</em> (see <a href="#isAlive()"><code>isAlive()</code></a>, and subsequent operation on the segment (or on any <a href="MemoryAddress.html" title="interface in jdk.incubator.foreign"><code>MemoryAddress</code></a> instance
 derived from it) will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 Closing a segment might trigger the releasing of the underlying memory resources associated with said segment, depending on
 the kind of memory segment being considered:
 <ul>
     <li>closing a native memory segment results in <em>freeing</em> the native memory associated with it</li>
     <li>closing a mapped memory segment results in the backing memory-mapped file to be unmapped</li>
     <li>closing a buffer, or a heap segment does not have any side-effect, other than marking the segment
     as <em>not alive</em> (see <a href="#isAlive()"><code>isAlive()</code></a>). Also, since the buffer and heap segments might keep
     strong references to the original buffer or array instance, it is the responsibility of clients to ensure that
     these segments are discarded in a timely manner, so as not to prevent garbage collection to reclaim the underlying
     objects.</li>
 </ul>

 <h2><a id="access-modes">Access modes</a></h2>

 Memory segments supports zero or more <em>access modes</em>. Supported access modes are <a href="#READ"><code>READ</code></a>,
 <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#ACQUIRE"><code>ACQUIRE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>. The set of access modes supported by a segment alters the
 set of operations that are supported by that segment. For instance, attempting to call <a href="#close()"><code>close()</code></a> on
 a segment which does not support the <a href="#CLOSE"><code>CLOSE</code></a> access mode will result in an exception.
 <p>
 The set of supported access modes can only be made stricter (by supporting <em>fewer</em> access modes). This means
 that restricting the set of access modes supported by a segment before sharing it with other clients
 is generally a good practice if the creator of the segment wants to retain some control over how the segment
 is going to be accessed.

 <h2>Memory segment views</h2>

 Memory segments support <em>views</em>. For instance, it is possible to alter the set of supported access modes,
 by creating an <em>immutable</em> view of a memory segment, as follows:
 <blockquote><pre><code>
MemorySegment segment = ...
MemorySegment roSegment = segment.withAccessModes(segment.accessModes() &amp; ~WRITE);
 </code></pre></blockquote>
 It is also possible to create views whose spatial bounds are stricter than the ones of the original segment
 (see <a href="#asSlice(long,long)"><code>asSlice(long, long)</code></a>).
 <p>
 Temporal bounds of the original segment are inherited by the view; that is, closing a segment view, such as a sliced
 view, will cause the original segment to be closed; as such special care must be taken when sharing views
 between multiple clients. If a client want to protect itself against early closure of a segment by
 another actor, it is the responsibility of that client to take protective measures, such as removing <a href="#CLOSE"><code>CLOSE</code></a>
 from the set of supported access modes, before sharing the view with another client.
 <p>
 To allow for interoperability with existing code, a byte buffer view can be obtained from a memory segment
 (see <a href="#asByteBuffer()"><code>asByteBuffer()</code></a>). This can be useful, for instance, for those clients that want to keep using the
 <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> API, but need to operate on large memory segments. Byte buffers obtained in such a way support
 the same spatial and temporal access restrictions associated to the memory segment from which they originated.

 <h2><a id="thread-confinement">Thread confinement</a></h2>

 Memory segments support strong thread-confinement guarantees. Upon creation, they are assigned an <em>owner thread</em>,
 typically the thread which initiated the creation operation. After creation, only the owner thread will be allowed
 to directly manipulate the memory segment (e.g. close the memory segment) or access the underlying memory associated with
 the segment using a memory access var handle. Any attempt to perform such operations from a thread other than the
 owner thread will result in a runtime failure.
 <p>
 Memory segments support <em>serial thread confinement</em>; that is, ownership of a memory segment can change (see
 <a href="#withOwnerThread(java.lang.Thread)"><code>withOwnerThread(Thread)</code></a>). This allows, for instance, for two threads <code>A</code> and <code>B</code> to share
 a segment in a controlled, cooperative and race-free fashion.
 <p>
 In some cases, it might be useful for multiple threads to process the contents of the same memory segment concurrently
 (e.g. in the case of parallel processing); while memory segments provide strong confinement guarantees, it is possible
 to obtain a <a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util"><code>Spliterator</code></a> from a segment, which can be used to slice the segment and allow multiple thread to
 work in parallel on disjoint segment slices (this assumes that the access mode <a href="#ACQUIRE"><code>ACQUIRE</code></a> is set).
 For instance, the following code can be used to sum all int values in a memory segment in parallel:
 <blockquote><pre><code>
MemorySegment segment = ...
SequenceLayout SEQUENCE_LAYOUT = MemoryLayout.ofSequence(1024, MemoryLayouts.JAVA_INT);
VarHandle VH_int = SEQUENCE_LAYOUT.elementLayout().varHandle(int.class);
int sum = StreamSupport.stream(MemorySegment.spliterator(segment, SEQUENCE_LAYOUT), true)
                       .mapToInt(s -&gt; (int)VH_int.get(s.baseAddress()))
                       .sum();
 </code></pre></blockquote></div>
<dl class="notes">
<dt>API Note:</dt>
<dd>In the future, if the Java language permits, <a href="MemorySegment.html" title="interface in jdk.incubator.foreign"><code>MemorySegment</code></a>
 may become a <code>sealed</code> interface, which would prohibit subclassing except by
 <a href="MappedMemorySegment.html" title="interface in jdk.incubator.foreign"><code>MappedMemorySegment</code></a> and other explicitly permitted subtypes.</dd>
<dt>Implementation Requirements:</dt>
<dd>Implementations of this interface are immutable, thread-safe and <a href="../../../../java.base/java/lang/doc-files/ValueBased.html">value-based</a>.</dd>
</dl>
</section>
<section class="summary">
<ul class="summary-list">
<!-- =========== FIELD SUMMARY =========== -->
<li>
<section class="field-summary" id="field.summary">
<h2>Field Summary</h2>
<div class="member-summary">
<table class="summary-table">
<caption><span>Fields</span></caption>
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Field</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ACQUIRE">ACQUIRE</a></span></code></th>
<td class="col-last">
<div class="block">Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
 (see <a href="#spliterator(S,jdk.incubator.foreign.SequenceLayout)"><code>spliterator(MemorySegment, SequenceLayout)</code></a>).</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ALL_ACCESS">ALL_ACCESS</a></span></code></th>
<td class="col-last">
<div class="block">Default access mode; this is a union of all the access modes supported by memory segments.</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#CLOSE">CLOSE</a></span></code></th>
<td class="col-last">
<div class="block">Close access mode; calling <a href="#close()"><code>close()</code></a> is supported by a segment which supports this access mode.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#HANDOFF">HANDOFF</a></span></code></th>
<td class="col-last">
<div class="block">Handoff access mode; this segment support serial thread-confinement via thread ownership changes
 (see <a href="#withOwnerThread(java.lang.Thread)"><code>withOwnerThread(Thread)</code></a>).</div>
</td>
</tr>
<tr class="alt-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#READ">READ</a></span></code></th>
<td class="col-last">
<div class="block">Read access mode; read operations are supported by a segment which supports this access mode.</div>
</td>
</tr>
<tr class="row-color">
<td class="col-first"><code>static int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#WRITE">WRITE</a></span></code></th>
<td class="col-last">
<div class="block">Write access mode; write operations are supported by a segment which supports this access mode.</div>
</td>
</tr>
</tbody>
</table>
</div>
</section>
</li>
<!-- ========== METHOD SUMMARY =========== -->
<li>
<section class="method-summary" id="method.summary">
<h2>Method Summary</h2>
<div class="member-summary" id="method-summary-table">
<div class="table-tabs" role="tablist" aria-orientation="horizontal"><button role="tab" aria-selected="true" aria-controls="method-summary-table.tabpanel" tabindex="0" onkeydown="switchTab(event)" id="t0" class="active-table-tab">All Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t1" class="table-tab" onclick="show(1);">Static Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t2" class="table-tab" onclick="show(2);">Instance Methods</button><button role="tab" aria-selected="false" aria-controls="method-summary-table.tabpanel" tabindex="-1" onkeydown="switchTab(event)" id="t3" class="table-tab" onclick="show(4);">Abstract Methods</button></div>
<div id="method-summary-table.tabpanel" role="tabpanel">
<table class="summary-table" aria-labelledby="t0">
<thead>
<tr>
<th class="col-first" scope="col">Modifier and Type</th>
<th class="col-second" scope="col">Method</th>
<th class="col-last" scope="col">Description</th>
</tr>
</thead>
<tbody>
<tr class="alt-color" id="i0">
<td class="col-first"><code>int</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#accessModes()">accessModes</a></span>()</code></th>
<td class="col-last">
<div class="block">Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
 <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#ACQUIRE"><code>ACQUIRE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>.</div>
</td>
</tr>
<tr class="row-color" id="i1">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allocateNative(long)">allocateNative</a></span>&#8203;(long&nbsp;bytesSize)</code></th>
<td class="col-last">
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).</div>
</td>
</tr>
<tr class="alt-color" id="i2">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allocateNative(long,long)">allocateNative</a></span>&#8203;(long&nbsp;bytesSize,
long&nbsp;alignmentBytes)</code></th>
<td class="col-last">
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
 alignment constraint (in bytes).</div>
</td>
</tr>
<tr class="row-color" id="i3">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#allocateNative(jdk.incubator.foreign.MemoryLayout)">allocateNative</a></span>&#8203;(<a href="MemoryLayout.html" title="interface in jdk.incubator.foreign">MemoryLayout</a>&nbsp;layout)</code></th>
<td class="col-last">
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.</div>
</td>
</tr>
<tr class="alt-color" id="i4">
<td class="col-first"><code><a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#asByteBuffer()">asByteBuffer</a></span>()</code></th>
<td class="col-last">
<div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>.</div>
</td>
</tr>
<tr class="row-color" id="i5">
<td class="col-first"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#asSlice(long,long)">asSlice</a></span>&#8203;(long&nbsp;offset,
long&nbsp;newSize)</code></th>
<td class="col-last">
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is specified by the given argument.</div>
</td>
</tr>
<tr class="alt-color" id="i6">
<td class="col-first"><code><a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#baseAddress()">baseAddress</a></span>()</code></th>
<td class="col-last">
<div class="block">The base memory address associated with this memory segment.</div>
</td>
</tr>
<tr class="row-color" id="i7">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#byteSize()">byteSize</a></span>()</code></th>
<td class="col-last">
<div class="block">The size (in bytes) of this memory segment.</div>
</td>
</tr>
<tr class="alt-color" id="i8">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#close()">close</a></span>()</code></th>
<td class="col-last">
<div class="block">Closes this memory segment.</div>
</td>
</tr>
<tr class="row-color" id="i9">
<td class="col-first"><code>void</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#copyFrom(jdk.incubator.foreign.MemorySegment)">copyFrom</a></span>&#8203;(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;src)</code></th>
<td class="col-last">
<div class="block">Performs a bulk copy from given source segment to this segment.</div>
</td>
</tr>
<tr class="alt-color" id="i10">
<td class="col-first"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#fill(byte)">fill</a></span>&#8203;(byte&nbsp;value)</code></th>
<td class="col-last">
<div class="block">Fills a value into this memory segment.</div>
</td>
</tr>
<tr class="row-color" id="i11">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#hasAccessModes(int)">hasAccessModes</a></span>&#8203;(int&nbsp;accessModes)</code></th>
<td class="col-last">
<div class="block">Does this segment support a given set of access modes?</div>
</td>
</tr>
<tr class="alt-color" id="i12">
<td class="col-first"><code>boolean</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#isAlive()">isAlive</a></span>()</code></th>
<td class="col-last">
<div class="block">Is this segment alive?</div>
</td>
</tr>
<tr class="row-color" id="i13">
<td class="col-first"><code>static <a href="MappedMemorySegment.html" title="interface in jdk.incubator.foreign">MappedMemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)">mapFromPath</a></span>&#8203;(<a href="../../../../java.base/java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
long&nbsp;bytesOffset,
long&nbsp;bytesSize,
<a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mapMode)</code></th>
<td class="col-last">
<div class="block">Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.</div>
</td>
</tr>
<tr class="alt-color" id="i14">
<td class="col-first"><code>long</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#mismatch(jdk.incubator.foreign.MemorySegment)">mismatch</a></span>&#8203;(<a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;other)</code></th>
<td class="col-last">
<div class="block">Finds and returns the offset, in bytes, of the first mismatch between
 this segment and a given other segment.</div>
</td>
</tr>
<tr class="row-color" id="i15">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(byte%5B%5D)">ofArray</a></span>&#8203;(byte[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.</div>
</td>
</tr>
<tr class="alt-color" id="i16">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(char%5B%5D)">ofArray</a></span>&#8203;(char[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated char array.</div>
</td>
</tr>
<tr class="row-color" id="i17">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(double%5B%5D)">ofArray</a></span>&#8203;(double[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated double array.</div>
</td>
</tr>
<tr class="alt-color" id="i18">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(float%5B%5D)">ofArray</a></span>&#8203;(float[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated float array.</div>
</td>
</tr>
<tr class="row-color" id="i19">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(int%5B%5D)">ofArray</a></span>&#8203;(int[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated int array.</div>
</td>
</tr>
<tr class="alt-color" id="i20">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(long%5B%5D)">ofArray</a></span>&#8203;(long[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated long array.</div>
</td>
</tr>
<tr class="row-color" id="i21">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofArray(short%5B%5D)">ofArray</a></span>&#8203;(short[]&nbsp;arr)</code></th>
<td class="col-last">
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated short array.</div>
</td>
</tr>
<tr class="alt-color" id="i22">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofByteBuffer(java.nio.ByteBuffer)">ofByteBuffer</a></span>&#8203;(<a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;bb)</code></th>
<td class="col-last">
<div class="block">Creates a new buffer memory segment that models the memory associated with the given byte
 buffer.</div>
</td>
</tr>
<tr class="row-color" id="i23">
<td class="col-first"><code>static <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ofNativeRestricted(jdk.incubator.foreign.MemoryAddress,long,java.lang.Thread,java.lang.Runnable,java.lang.Object)">ofNativeRestricted</a></span>&#8203;(<a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;addr,
long&nbsp;bytesSize,
<a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;owner,
<a href="../../../../java.base/java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&nbsp;cleanup,
<a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;attachment)</code></th>
<td class="col-last">
<div class="block">Returns a new native memory segment with given base address and size; the returned segment has its own temporal
 bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
 action.</div>
</td>
</tr>
<tr class="alt-color" id="i24">
<td class="col-first"><code><a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#ownerThread()">ownerThread</a></span>()</code></th>
<td class="col-last">
<div class="block">The thread owning this segment.</div>
</td>
</tr>
<tr class="row-color" id="i25">
<td class="col-first"><code>static &lt;S extends <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;<br><a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;S&gt;</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#spliterator(S,jdk.incubator.foreign.SequenceLayout)">spliterator</a></span>&#8203;(S&nbsp;segment,
<a href="SequenceLayout.html" title="class in jdk.incubator.foreign">SequenceLayout</a>&nbsp;layout)</code></th>
<td class="col-last">
<div class="block">Returns a spliterator for the given memory segment.</div>
</td>
</tr>
<tr class="alt-color" id="i26">
<td class="col-first"><code>byte[]</code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#toByteArray()">toByteArray</a></span>()</code></th>
<td class="col-last">
<div class="block">Copy the contents of this memory segment into a fresh byte array.</div>
</td>
</tr>
<tr class="row-color" id="i27">
<td class="col-first"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#withAccessModes(int)">withAccessModes</a></span>&#8203;(int&nbsp;accessModes)</code></th>
<td class="col-last">
<div class="block">Obtains a segment view with specific <a href="#access-modes">access modes</a>.</div>
</td>
</tr>
<tr class="alt-color" id="i28">
<td class="col-first"><code><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></code></td>
<th class="col-second" scope="row"><code><span class="member-name-link"><a href="#withOwnerThread(java.lang.Thread)">withOwnerThread</a></span>&#8203;(<a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;newOwner)</code></th>
<td class="col-last">
<div class="block">Obtains a new memory segment backed by the same underlying memory region as this segment,
 but with different owner thread.</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
</section>
</li>
</ul>
</section>
<section class="details">
<ul class="details-list">
<!-- ============ FIELD DETAIL =========== -->
<li>
<section class="field-details" id="field.detail">
<h2>Field Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="READ">
<h3>READ</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">READ</span></div>
<div class="block">Read access mode; read operations are supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.READ">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="WRITE">
<h3>WRITE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">WRITE</span></div>
<div class="block">Write access mode; write operations are supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.WRITE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="CLOSE">
<h3>CLOSE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">CLOSE</span></div>
<div class="block">Close access mode; calling <a href="#close()"><code>close()</code></a> is supported by a segment which supports this access mode.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.CLOSE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ACQUIRE">
<h3>ACQUIRE</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">ACQUIRE</span></div>
<div class="block">Acquire access mode; this segment support sharing with threads other than the owner thread, via spliterator
 (see <a href="#spliterator(S,jdk.incubator.foreign.SequenceLayout)"><code>spliterator(MemorySegment, SequenceLayout)</code></a>).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.ACQUIRE">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="HANDOFF">
<h3>HANDOFF</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">HANDOFF</span></div>
<div class="block">Handoff access mode; this segment support serial thread-confinement via thread ownership changes
 (see <a href="#withOwnerThread(java.lang.Thread)"><code>withOwnerThread(Thread)</code></a>).</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.HANDOFF">Constant Field Values</a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ALL_ACCESS">
<h3>ALL_ACCESS</h3>
<div class="member-signature"><span class="modifiers">static final</span>&nbsp;<span class="return-type">int</span>&nbsp;<span class="member-name">ALL_ACCESS</span></div>
<div class="block">Default access mode; this is a union of all the access modes supported by memory segments.</div>
<dl class="notes">
<dt>See Also:</dt>
<dd><a href="#accessModes()"><code>accessModes()</code></a>, 
<a href="#withAccessModes(int)"><code>withAccessModes(int)</code></a>, 
<a href="../../../../constant-values.html#jdk.incubator.foreign.MemorySegment.ALL_ACCESS">Constant Field Values</a></dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
<!-- ============ METHOD DETAIL ========== -->
<li>
<section class="method-details" id="method.detail">
<h2>Method Details</h2>
<ul class="member-list">
<li>
<section class="detail" id="baseAddress()">
<h3>baseAddress</h3>
<div class="member-signature"><span class="return-type"><a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a></span>&nbsp;<span class="member-name">baseAddress</span>()</div>
<div class="block">The base memory address associated with this memory segment. The returned address is
 a <em>checked</em> memory address and can therefore be used in derefrence operations
 (see <a href="MemoryAddress.html" title="interface in jdk.incubator.foreign"><code>MemoryAddress</code></a>).</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The base memory address.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="spliterator(S,jdk.incubator.foreign.SequenceLayout)">
<h3 id="spliterator(jdk.incubator.foreign.MemorySegment,jdk.incubator.foreign.SequenceLayout)">spliterator</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="type-parameters">&lt;S extends <a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&gt;</span>&nbsp;<span class="return-type"><a href="../../../../java.base/java/util/Spliterator.html" title="interface in java.util">Spliterator</a>&lt;S&gt;</span>&nbsp;<span class="member-name">spliterator</span>&#8203;(<span class="parameters">S&nbsp;segment,
<a href="SequenceLayout.html" title="class in jdk.incubator.foreign">SequenceLayout</a>&nbsp;layout)</span></div>
<div class="block">Returns a spliterator for the given memory segment. The returned spliterator reports <a href="../../../../java.base/java/util/Spliterator.html#SIZED"><code>Spliterator.SIZED</code></a>,
 <a href="../../../../java.base/java/util/Spliterator.html#SUBSIZED"><code>Spliterator.SUBSIZED</code></a>, <a href="../../../../java.base/java/util/Spliterator.html#IMMUTABLE"><code>Spliterator.IMMUTABLE</code></a>, <a href="../../../../java.base/java/util/Spliterator.html#NONNULL"><code>Spliterator.NONNULL</code></a> and <a href="../../../../java.base/java/util/Spliterator.html#ORDERED"><code>Spliterator.ORDERED</code></a>
 characteristics.
 <p>
 The returned spliterator splits the segment according to the specified sequence layout; that is,
 if the supplied layout is a sequence layout whose element count is <code>N</code>, then calling <a href="../../../../java.base/java/util/Spliterator.html#trySplit()"><code>Spliterator.trySplit()</code></a>
 will result in a spliterator serving approximatively <code>N/2</code> elements (depending on whether N is even or not).
 As such, splitting is possible as long as <code>N &gt;= 2</code>. The spliterator returns segments that feature the same
 <a href="#access-modes">access modes</a> as the given segment less the <a href="#CLOSE"><code>CLOSE</code></a> access mode.
 <p>
 The returned spliterator effectively allows to slice a segment into disjoint sub-segments, which can then
 be processed in parallel by multiple threads (if the access mode <a href="#ACQUIRE"><code>ACQUIRE</code></a> is set).
 While closing the segment (see <a href="#close()"><code>close()</code></a>) during pending concurrent execution will generally
 fail with an exception, it is possible to close a segment when a spliterator has been obtained but no thread
 is actively working on it using <a href="../../../../java.base/java/util/Spliterator.html#tryAdvance(java.util.function.Consumer)"><code>Spliterator.tryAdvance(Consumer)</code></a>; in such cases, any subsequent call
 to <a href="../../../../java.base/java/util/Spliterator.html#tryAdvance(java.util.function.Consumer)"><code>Spliterator.tryAdvance(Consumer)</code></a> will fail with an exception.</div>
<dl class="notes">
<dt>Type Parameters:</dt>
<dd><code>S</code> - the memory segment type</dd>
<dt>Parameters:</dt>
<dd><code>segment</code> - the segment to be used for splitting.</dd>
<dd><code>layout</code> - the layout to be used for splitting.</dd>
<dt>Returns:</dt>
<dd>the element spliterator for this segment</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if the segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ownerThread()">
<h3>ownerThread</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a></span>&nbsp;<span class="member-name">ownerThread</span>()</div>
<div class="block">The thread owning this segment.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="withOwnerThread(java.lang.Thread)">
<h3>withOwnerThread</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">withOwnerThread</span>&#8203;(<span class="parameters"><a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;newOwner)</span></div>
<div class="block">Obtains a new memory segment backed by the same underlying memory region as this segment,
 but with different owner thread. As a side-effect, this segment will be marked as <em>not alive</em>,
 and subsequent operations on this segment will result in runtime errors.
 <p>
 Write accesses to the segment's content <a href="../../../java/util/concurrent/package-summary.html#MemoryVisibility"><i>happens-before</i></a>
 hand-over from the current owner thread to the new owner thread, which in turn <i>happens before</i> read accesses to the segment's contents on
 the new owner thread.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>newOwner</code> - the new owner thread.</dd>
<dt>Returns:</dt>
<dd>a new memory segment backed by the same underlying memory region as this segment,
      owned by <code>newOwner</code>.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
 thread (see <a href="#spliterator(S,jdk.incubator.foreign.SequenceLayout)"><code>spliterator(MemorySegment, SequenceLayout)</code></a>).</dd>
<dd><code><a href="../../../../java.base/java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if <code>newOwner == null</code></dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the segment is already a confined segment owner by <code>newOnwer</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#HANDOFF"><code>HANDOFF</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="byteSize()">
<h3>byteSize</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">byteSize</span>()</div>
<div class="block">The size (in bytes) of this memory segment.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>The size (in bytes) of this memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="withAccessModes(int)">
<h3>withAccessModes</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">withAccessModes</span>&#8203;(<span class="parameters">int&nbsp;accessModes)</span></div>
<div class="block">Obtains a segment view with specific <a href="#access-modes">access modes</a>. Supported access modes are <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>,
 <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#ACQUIRE"><code>ACQUIRE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>. It is generally not possible to go from a segment with stricter access modes
 to one with less strict access modes. For instance, attempting to add <a href="#WRITE"><code>WRITE</code></a> access mode to a read-only segment
 will be met with an exception.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>accessModes</code> - an ORed mask of zero or more access modes.</dd>
<dt>Returns:</dt>
<dd>a segment view with specific access modes.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - when <code>mask</code> is an access mask which is less strict than the one supported by this
 segment, or when <code>mask</code> contains bits not associated with any of the supported access modes.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="hasAccessModes(int)">
<h3>hasAccessModes</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">hasAccessModes</span>&#8203;(<span class="parameters">int&nbsp;accessModes)</span></div>
<div class="block">Does this segment support a given set of access modes?</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>accessModes</code> - an ORed mask of zero or more access modes.</dd>
<dt>Returns:</dt>
<dd>true, if the access modes in <code>accessModes</code> are stricter than the ones supported by this segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - when <code>mask</code> contains bits not associated with any of the supported access modes.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="accessModes()">
<h3>accessModes</h3>
<div class="member-signature"><span class="return-type">int</span>&nbsp;<span class="member-name">accessModes</span>()</div>
<div class="block">Returns the <a href="#access-modes">access modes</a> associated with this segment; the result is represented as ORed values from
 <a href="#READ"><code>READ</code></a>, <a href="#WRITE"><code>WRITE</code></a>, <a href="#CLOSE"><code>CLOSE</code></a>, <a href="#ACQUIRE"><code>ACQUIRE</code></a> and <a href="#HANDOFF"><code>HANDOFF</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>the access modes associated with this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asSlice(long,long)">
<h3>asSlice</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">asSlice</span>&#8203;(<span class="parameters">long&nbsp;offset,
long&nbsp;newSize)</span></div>
<div class="block">Obtains a new memory segment view whose base address is the same as the base address of this segment plus a given offset,
 and whose new size is specified by the given argument.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>offset</code> - The new segment base offset (relative to the current segment base address), specified in bytes.</dd>
<dd><code>newSize</code> - The new segment size, specified in bytes.</dd>
<dt>Returns:</dt>
<dd>a new memory segment view with updated base/limit addresses.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>offset &lt; 0</code>, <code>offset &gt; byteSize()</code>, <code>newSize &lt; 0</code>, or <code>newSize &gt; byteSize() - offset</code></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="isAlive()">
<h3>isAlive</h3>
<div class="member-signature"><span class="return-type">boolean</span>&nbsp;<span class="member-name">isAlive</span>()</div>
<div class="block">Is this segment alive?</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>true, if the segment is alive.</dd>
<dt>See Also:</dt>
<dd><a href="#close()"><code>close()</code></a></dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="close()">
<h3>close</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="member-name">close</span>()</div>
<div class="block">Closes this memory segment. Once a memory segment has been closed, any attempt to use the memory segment,
 or to access any <a href="MemoryAddress.html" title="interface in jdk.incubator.foreign"><code>MemoryAddress</code></a> instance associated with it will fail with <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 Depending on the kind of memory segment being closed, calling this method further triggers deallocation of all the resources
 associated with the memory segment.</div>
<dl class="notes">
<dt>Specified by:</dt>
<dd><code><a href="../../../../java.base/java/lang/AutoCloseable.html#close()">close</a></code>&nbsp;in interface&nbsp;<code><a href="../../../../java.base/java/lang/AutoCloseable.html" title="interface in java.lang">AutoCloseable</a></code></dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment, or if the segment cannot be closed because it is being operated upon by a different
 thread (see <a href="#spliterator(S,jdk.incubator.foreign.SequenceLayout)"><code>spliterator(MemorySegment, SequenceLayout)</code></a>).</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#CLOSE"><code>CLOSE</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="fill(byte)">
<h3>fill</h3>
<div class="member-signature"><span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">fill</span>&#8203;(<span class="parameters">byte&nbsp;value)</span></div>
<div class="block">Fills a value into this memory segment.
 <p>
 More specifically, the given value is filled into each address of this
 segment. Equivalent to (but likely more efficient than) the following code:

 <pre><code>
byteHandle = MemoryLayout.ofSequence(MemoryLayouts.JAVA_BYTE)
         .varHandle(byte.class, MemoryLayout.PathElement.sequenceElement());
for (long l = 0; l &lt; segment.byteSize(); l++) {
     byteHandle.set(segment.baseAddress(), l, value);
}
 </code></pre>

 without any regard or guarantees on the ordering of particular memory
 elements being set.
 <p>
 Fill can be useful to initialize or reset the memory of a segment.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>value</code> - the value to fill into this segment</dd>
<dt>Returns:</dt>
<dd>this memory segment</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment is not <em>alive</em>, or if access occurs from a thread other than the
 thread owning this segment</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not support the <a href="#WRITE"><code>WRITE</code></a> access mode</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="copyFrom(jdk.incubator.foreign.MemorySegment)">
<h3>copyFrom</h3>
<div class="member-signature"><span class="return-type">void</span>&nbsp;<span class="member-name">copyFrom</span>&#8203;(<span class="parameters"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;src)</span></div>
<div class="block">Performs a bulk copy from given source segment to this segment. More specifically, the bytes at
 offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment are copied into this segment
 at offset <code>0</code> through <code>src.byteSize() - 1</code>.
 If the source segment overlaps with this segment, then the copying is performed as if the bytes at
 offset <code>0</code> through <code>src.byteSize() - 1</code> in the source segment were first copied into a
 temporary segment with size <code>bytes</code>, and then the contents of the temporary segment were copied into
 this segment at offset <code>0</code> through <code>src.byteSize() - 1</code>.
 <p>
 The result of a bulk copy is unspecified if, in the uncommon case, the source segment and this segment
 do not overlap, but refer to overlapping regions of the same backing storage using different addresses.
 For example, this may occur if the same file is <a href="#mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)"><code>mapped</code></a> to two segments.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>src</code> - the source segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IndexOutOfBoundsException.html" title="class in java.lang">IndexOutOfBoundsException</a></code> - if <code>src.byteSize() &gt; this.byteSize()</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if either the source segment or this segment have been already closed,
 or if access occurs from a thread other than the thread owning either segment.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if either the source segment or this segment do not feature required access modes;
 more specifically, <code>src</code> should feature at least the <a href="#READ"><code>READ</code></a> access mode,
 while this segment should feature at least the <a href="#WRITE"><code>WRITE</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mismatch(jdk.incubator.foreign.MemorySegment)">
<h3>mismatch</h3>
<div class="member-signature"><span class="return-type">long</span>&nbsp;<span class="member-name">mismatch</span>&#8203;(<span class="parameters"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a>&nbsp;other)</span></div>
<div class="block">Finds and returns the offset, in bytes, of the first mismatch between
 this segment and a given other segment. The offset is relative to the
 <a href="#baseAddress()"><code>base address</code></a> of each segment and will be in the
 range of 0 (inclusive) up to the <a href="#byteSize()"><code>size</code></a> (in bytes) of
 the smaller memory segment (exclusive).
 <p>
 If the two segments share a common prefix then the returned offset is
 the length of the common prefix and it follows that there is a mismatch
 between the two segments at that offset within the respective segments.
 If one segment is a proper prefix of the other then the returned offset is
 the smaller of the segment sizes, and it follows that the offset is only
 valid for the larger segment. Otherwise, there is no mismatch and <code>
 -1</code> is returned.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>other</code> - the segment to be tested for a mismatch with this segment</dd>
<dt>Returns:</dt>
<dd>the relative offset, in bytes, of the first mismatch between this
 and the given other segment, otherwise -1 if no mismatch</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if either this segment of the other segment
 have been already closed, or if access occurs from a thread other than the
 thread owning either segment</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if either this segment or the other
 segment does not feature at least the <a href="#READ"><code>READ</code></a> access mode</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="asByteBuffer()">
<h3>asByteBuffer</h3>
<div class="member-signature"><span class="return-type"><a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a></span>&nbsp;<span class="member-name">asByteBuffer</span>()</div>
<div class="block">Wraps this segment in a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a>. Some of the properties of the returned buffer are linked to
 the properties of this segment. For instance, if this segment is <em>immutable</em>
 (e.g. the segment has access mode <a href="#READ"><code>READ</code></a> but not <a href="#WRITE"><code>WRITE</code></a>), then the resulting buffer is <em>read-only</em>
 (see <a href="../../../../java.base/java/nio/Buffer.html#isReadOnly()"><code>Buffer.isReadOnly()</code></a>. Additionally, if this is a native memory segment, the resulting buffer is
 <em>direct</em> (see <a href="../../../../java.base/java/nio/ByteBuffer.html#isDirect()"><code>ByteBuffer.isDirect()</code></a>).
 <p>
 The life-cycle of the returned buffer will be tied to that of this segment. That means that if the this segment
 is closed (see <a href="#close()"><code>close()</code></a>, accessing the returned
 buffer will throw an <a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang"><code>IllegalStateException</code></a>.
 <p>
 The resulting buffer's byte order is <a href="../../../../java.base/java/nio/ByteOrder.html#BIG_ENDIAN"><code>ByteOrder.BIG_ENDIAN</code></a>; this can be changed using
 <a href="../../../../java.base/java/nio/ByteBuffer.html#order(java.nio.ByteOrder)"><code>ByteBuffer.order(java.nio.ByteOrder)</code></a>.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> view of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment cannot be mapped onto a <a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio"><code>ByteBuffer</code></a> instance,
 e.g. because it models an heap-based segment that is not based on a <code>byte[]</code>), or if its size is greater
 than <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>, or if the segment does not support the <a href="#READ"><code>READ</code></a> access mode.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="toByteArray()">
<h3>toByteArray</h3>
<div class="member-signature"><span class="return-type">byte[]</span>&nbsp;<span class="member-name">toByteArray</span>()</div>
<div class="block">Copy the contents of this memory segment into a fresh byte array.</div>
<dl class="notes">
<dt>Returns:</dt>
<dd>a fresh byte array copy of this memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if this segment does not feature the <a href="#READ"><code>READ</code></a> access mode, or if this
 segment's contents cannot be copied into a <code>byte</code> instance, e.g. its size is greater than <a href="../../../../java.base/java/lang/Integer.html#MAX_VALUE"><code>Integer.MAX_VALUE</code></a>,</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalStateException.html" title="class in java.lang">IllegalStateException</a></code> - if this segment has been closed, or if access occurs from a thread other than the
 thread owning this segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofByteBuffer(java.nio.ByteBuffer)">
<h3>ofByteBuffer</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofByteBuffer</span>&#8203;(<span class="parameters"><a href="../../../../java.base/java/nio/ByteBuffer.html" title="class in java.nio">ByteBuffer</a>&nbsp;bb)</span></div>
<div class="block">Creates a new buffer memory segment that models the memory associated with the given byte
 buffer. The segment starts relative to the buffer's position (inclusive)
 and ends relative to the buffer's limit (exclusive).
 <p>
 The segment will feature all <a href="#access-modes">access modes</a> (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>),
 unless the given buffer is <a href="../../../../java.base/java/nio/Buffer.html#isReadOnly()">read-only</a> in which case the segment will
 not feature the <a href="#WRITE"><code>WRITE</code></a> access mode.
 <p>
 The resulting memory segment keeps a reference to the backing buffer, to ensure it remains <em>reachable</em>
 for the life-time of the segment.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>bb</code> - the byte buffer backing the buffer memory segment.</dd>
<dt>Returns:</dt>
<dd>a new buffer memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(byte[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">byte[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated byte array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(char[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">char[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated char array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(short[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">short[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated short array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(int[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">int[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated int array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(float[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">float[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated float array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(long[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">long[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated long array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofArray(double[])">
<h3>ofArray</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofArray</span>&#8203;(<span class="parameters">double[]&nbsp;arr)</span></div>
<div class="block">Creates a new array memory segment that models the memory associated with a given heap-allocated double array.
 <p>
 The resulting memory segment keeps a reference to the backing array, to ensure it remains <em>reachable</em>
 for the life-time of the segment. The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>arr</code> - the primitive array backing the array memory segment.</dd>
<dt>Returns:</dt>
<dd>a new array memory segment.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(jdk.incubator.foreign.MemoryLayout)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">allocateNative</span>&#8203;(<span class="parameters"><a href="MemoryLayout.html" title="interface in jdk.incubator.foreign">MemoryLayout</a>&nbsp;layout)</span></div>
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given layout.
 <p>
 This is equivalent to the following code:
 <blockquote><pre><code>
    allocateNative(layout.bytesSize(), layout.bytesAlignment());
 </code></pre></blockquote></div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>layout</code> - the layout of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if the specified layout has illegal size or alignment constraint.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(long)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">allocateNative</span>&#8203;(<span class="parameters">long&nbsp;bytesSize)</span></div>
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given size (in bytes).
 <p>
 This is equivalent to the following code:
 <blockquote><pre><code>
allocateNative(bytesSize, 1);
 </code></pre></blockquote></div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt; 0</code>.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="mapFromPath(java.nio.file.Path,long,long,java.nio.channels.FileChannel.MapMode)">
<h3>mapFromPath</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MappedMemorySegment.html" title="interface in jdk.incubator.foreign">MappedMemorySegment</a></span>&nbsp;<span class="member-name">mapFromPath</span>&#8203;(<span class="parameters"><a href="../../../../java.base/java/nio/file/Path.html" title="interface in java.nio.file">Path</a>&nbsp;path,
long&nbsp;bytesOffset,
long&nbsp;bytesSize,
<a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html" title="class in java.nio.channels">FileChannel.MapMode</a>&nbsp;mapMode)</span>
                                throws <span class="exceptions"><a href="../../../../java.base/java/io/IOException.html" title="class in java.io">IOException</a></span></div>
<div class="block">Creates a new mapped memory segment that models a memory-mapped region of a file from a given path.
 <p>
 The segment will feature all <a href="#access-modes">access modes</a> (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>),
 unless the given mapping mode is <a href="../../../../java.base/java/nio/channels/FileChannel.MapMode.html#READ_ONLY">READ_ONLY</a>, in which case
 the segment will not feature the <a href="#WRITE"><code>WRITE</code></a> access mode.</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>When obtaining a mapped segment from a newly created file, the initialization state of the contents of the block
 of mapped memory associated with the returned mapped memory segment is unspecified and should not be relied upon.</dd>
<dt>Parameters:</dt>
<dd><code>path</code> - the path to the file to memory map.</dd>
<dd><code>bytesOffset</code> - the offset (expressed in bytes) within the file at which the mapped segment is to start.</dd>
<dd><code>bytesSize</code> - the size (in bytes) of the mapped memory backing the memory segment.</dd>
<dd><code>mapMode</code> - a file mapping mode, see <a href="../../../../java.base/java/nio/channels/FileChannel.html#map(java.nio.channels.FileChannel.MapMode,long,long)"><code>FileChannel.map(FileChannel.MapMode, long, long)</code></a>; the chosen mapping mode
                might affect the behavior of the returned memory mapped segment (see <a href="MappedMemorySegment.html#force()"><code>MappedMemorySegment.force()</code></a>).</dd>
<dt>Returns:</dt>
<dd>a new mapped memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesOffset &lt; 0</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt; 0</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if an unsupported map mode is specified.</dd>
<dd><code><a href="../../../../java.base/java/io/IOException.html" title="class in java.io">IOException</a></code> - if the specified path does not point to an existing file, or if some other I/O error occurs.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="allocateNative(long,long)">
<h3>allocateNative</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">allocateNative</span>&#8203;(<span class="parameters">long&nbsp;bytesSize,
long&nbsp;alignmentBytes)</span></div>
<div class="block">Creates a new native memory segment that models a newly allocated block of off-heap memory with given size and
 alignment constraint (in bytes). The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).</div>
<dl class="notes">
<dt>Implementation Note:</dt>
<dd>The block of off-heap memory associated with the returned native memory segment is initialized to zero.
 Moreover, a client is responsible to call the <a href="#close()"><code>close()</code></a> on a native memory segment,
 to make sure the backing off-heap memory block is deallocated accordingly. Failure to do so will result in off-heap memory leaks.</dd>
<dt>Parameters:</dt>
<dd><code>bytesSize</code> - the size (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dd><code>alignmentBytes</code> - the alignment constraint (in bytes) of the off-heap memory block backing the native memory segment.</dd>
<dt>Returns:</dt>
<dd>a new native memory segment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt; 0</code>, <code>alignmentBytes &lt; 0</code>, or if <code>alignmentBytes</code>
 is not a power of 2.</dd>
</dl>
</section>
</li>
<li>
<section class="detail" id="ofNativeRestricted(jdk.incubator.foreign.MemoryAddress,long,java.lang.Thread,java.lang.Runnable,java.lang.Object)">
<h3>ofNativeRestricted</h3>
<div class="member-signature"><span class="modifiers">static</span>&nbsp;<span class="return-type"><a href="MemorySegment.html" title="interface in jdk.incubator.foreign">MemorySegment</a></span>&nbsp;<span class="member-name">ofNativeRestricted</span>&#8203;(<span class="parameters"><a href="MemoryAddress.html" title="interface in jdk.incubator.foreign">MemoryAddress</a>&nbsp;addr,
long&nbsp;bytesSize,
<a href="../../../../java.base/java/lang/Thread.html" title="class in java.lang">Thread</a>&nbsp;owner,
<a href="../../../../java.base/java/lang/Runnable.html" title="interface in java.lang">Runnable</a>&nbsp;cleanup,
<a href="../../../../java.base/java/lang/Object.html" title="class in java.lang">Object</a>&nbsp;attachment)</span></div>
<div class="block">Returns a new native memory segment with given base address and size; the returned segment has its own temporal
 bounds, and can therefore be closed; closing such a segment can optionally result in calling an user-provided cleanup
 action. This method can be very useful when interacting with custom native memory sources (e.g. custom allocators,
 GPU memory, etc.), where an address to some underlying memory region is typically obtained from native code
 (often as a plain <code>long</code> value). The segment will feature all <a href="#access-modes">access modes</a>
 (see <a href="#ALL_ACCESS"><code>ALL_ACCESS</code></a>).
 <p>
 This method is <em>restricted</em>. Restricted methods are unsafe, and, if used incorrectly, their use might crash
 the JVM or, worse, silently result in memory corruption. Thus, clients should refrain from depending on
 restricted methods, and use safe and supported functionalities, where possible.</div>
<dl class="notes">
<dt>Parameters:</dt>
<dd><code>addr</code> - the desired base address</dd>
<dd><code>bytesSize</code> - the desired size.</dd>
<dd><code>owner</code> - the desired owner thread. If <code>owner == null</code>, the returned segment is <em>not</em> confined.</dd>
<dd><code>cleanup</code> - a cleanup action to be executed when the <a href="#close()"><code>close()</code></a> method is called on the
                returned segment. If <code>cleanup == null</code>, no cleanup action is executed.</dd>
<dd><code>attachment</code> - an object that must be kept alive by the returned segment; this can be useful when
                   the returned segment depends on memory which could be released if a certain object
                   is determined to be unreacheable. In most cases this will be set to <code>null</code>.</dd>
<dt>Returns:</dt>
<dd>a new native memory segment with given base address, size, owner, cleanup action and object attachment.</dd>
<dt>Throws:</dt>
<dd><code><a href="../../../../java.base/java/lang/IllegalArgumentException.html" title="class in java.lang">IllegalArgumentException</a></code> - if <code>bytesSize &lt;= 0</code>.</dd>
<dd><code><a href="../../../../java.base/java/lang/UnsupportedOperationException.html" title="class in java.lang">UnsupportedOperationException</a></code> - if <code>addr</code> is associated with an heap segment.</dd>
<dd><code><a href="../../../../java.base/java/lang/IllegalAccessError.html" title="class in java.lang">IllegalAccessError</a></code> - if the runtime property <code>foreign.restricted</code> is not set to either
 <code>permit</code>, <code>warn</code> or <code>debug</code> (the default value is set to <code>deny</code>).</dd>
<dd><code><a href="../../../../java.base/java/lang/NullPointerException.html" title="class in java.lang">NullPointerException</a></code> - if <code>addr == null</code>.</dd>
</dl>
</section>
</li>
</ul>
</section>
</li>
</ul>
</section>
<!-- ========= END OF CLASS DATA ========= -->
</main>
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottom-nav" id="navbar.bottom">
<div class="skip-nav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<ul id="navbar.bottom.firstrow" class="nav-list" title="Navigation">
<li><a href="../../../../index.html">Overview</a></li>
<li><a href="../../../module-summary.html">Module</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="nav-bar-cell1-rev">Class</li>
<li><a href="class-use/MemorySegment.html">Use</a></li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../../index-files/index-1.html">Index</a></li>
<li><a href="../../../../help-doc.html">Help</a></li>
</ul>
<div class="about-language"><div style="margin-top: 14px;"><strong>Java SE 15 &amp; JDK 15</strong> </div></div>
</div>
<div class="sub-nav">
<div>
<ul class="sub-nav-list">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="sub-nav-list">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li>Constr&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
</div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<span class="skip-nav" id="skip.navbar.bottom">
<!--   -->
</span></nav>
<p class="legal-copy"><small><a href="https://bugreport.java.com/bugreport/">Report a bug or suggest an enhancement</a><br> For further API reference and developer documentation see the <a href="https://docs.oracle.com/pls/topic/lookup?ctx=javase15.0.1&amp;id=homepage" target="_blank">Java SE Documentation</a>, which contains more detailed, developer-targeted descriptions with conceptual overviews, definitions of terms, workarounds, and working code examples.<br> Java is a trademark or registered trademark of Oracle and/or its affiliates in the US and other countries.<br> <a href="../../../../../legal/copyright.html">Copyright</a> &copy; 1993, 2020, Oracle and/or its affiliates, 500 Oracle Parkway, Redwood Shores, CA 94065 USA.<br>All rights reserved. Use is subject to <a href="https://www.oracle.com/technetwork/java/javase/terms/license/java15.0.1speclicense.html">license terms</a> and the <a href="https://www.oracle.com/technetwork/java/redist-137594.html">documentation redistribution policy</a>. <!-- Version 15.0.1+9-18 --></small></p>
</footer>
</div>
</div>
</body>
</html>
